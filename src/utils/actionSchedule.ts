import { ActionSchedule } from '@prisma/client'
import { DAY_NAMES, numberWithOrdinal, timeToDisplayString } from './date'
import { TimeZone } from './timezones'
import Cron from 'croner'

export type CronSchedule = {
  once?: boolean
  timeZoneName: string // Also a TimeZone, broad for deserializing convenience
  runnerId?: string | null
  notifyOnSuccess?: boolean
  second: string
  minute: string
  hour: string
  dayOfMonth: string
  month: string
  dayOfWeek: string
  date?: string | null
}

export function cronSchedulesEqual(a: CronSchedule, b: CronSchedule) {
  for (const propName of [
    'second',
    'minute',
    'hour',
    'dayOfMonth',
    'month',
    'dayOfWeek',
    'timeZoneName',
    'runnerId',
    'once',
    'date',
  ]) {
    if (a[propName] !== b[propName]) return false
  }

  return true
}

export function cronScheduleToString(schedule: CronSchedule): string {
  if (schedule.date) {
    return schedule.date
  }
  return [
    schedule.second,
    schedule.minute,
    schedule.hour,
    schedule.dayOfMonth,
    schedule.month,
    schedule.dayOfWeek,
  ].join(' ')
}

export type SchedulePeriod = 'now' | 'once' | 'hour' | 'day' | 'week' | 'month'

export type ScheduleInput = {
  schedulePeriod: SchedulePeriod
  timeZoneName?: TimeZone
  seconds?: number
  hours?: number
  minutes?: number
  dayOfWeek?: number
  dayOfMonth?: number
  date?: string | null
  runnerId?: string | null
  notifyOnSuccess?: boolean
}

export function actionScheduleToDescriptiveString(
  schedule: ActionSchedule
): string {
  const { minute, hour, dayOfMonth, dayOfWeek, timeZoneName, once } = schedule

  const timeString = timeToDisplayString(
    Number(hour),
    Number(minute),
    timeZoneName
  )

  if (once) {
    const cron = new Cron(cronScheduleToString(schedule), { maxRuns: 1 })
    const nextRun = cron.nextRun()
    if (!nextRun) return 'never'
    return `once at ${nextRun.toLocaleString()}`
  }

  if (dayOfMonth !== '*') {
    return `every month on the ${numberWithOrdinal(
      Number(dayOfMonth)
    )} at ${timeString}`
  }

  if (dayOfWeek !== '*') {
    return `every week on ${DAY_NAMES[dayOfWeek]} at ${timeString}`
  }

  if (hour !== '*') {
    return `every day at ${timeString}`
  }

  return `every hour`
}

/**
 * This assumes well-formed simple cron schedules generated by toCronSchedule below.
 */
export function toScheduleInput(schedule: CronSchedule): ScheduleInput {
  const seconds = Number(schedule.second)
  const hours = Number(schedule.hour)
  const minutes = Number(schedule.minute)
  const dayOfWeek = Number(schedule.dayOfWeek)
  const dayOfMonth = Number(schedule.dayOfMonth)

  let schedulePeriod: SchedulePeriod
  if (schedule.date) {
    schedulePeriod = 'once'
  } else if (schedule.once) {
    schedulePeriod = Number.isNaN(seconds) ? 'now' : 'once'
  } else {
    schedulePeriod = !Number.isNaN(dayOfMonth)
      ? 'month'
      : !Number.isNaN(dayOfWeek)
      ? 'week'
      : !Number.isNaN(hours)
      ? 'day'
      : 'hour'
  }

  const common = {
    schedulePeriod,
    timeZoneName: schedule.timeZoneName as TimeZone,
    runnerId: schedule.runnerId,
    notifyOnSuccess: schedule.notifyOnSuccess,
  }

  switch (schedulePeriod) {
    case 'once':
      if ('date' in schedule) {
        return {
          ...common,
          date: schedule.date,
        }
      }
      return {
        ...common,
        seconds,
        minutes,
        hours,
        dayOfWeek,
        dayOfMonth,
      }
    case 'now':
    case 'hour':
      return common
    case 'day':
      return {
        ...common,
        seconds,
        minutes,
        hours,
      }
    case 'week':
      return {
        ...common,
        seconds,
        minutes,
        hours,
        dayOfWeek,
      }
    case 'month':
      return {
        ...common,
        seconds,
        minutes,
        hours,
        dayOfMonth,
      }
  }
}

export function toCronSchedule({
  schedulePeriod,
  timeZoneName = 'UTC',
  hours,
  seconds,
  minutes,
  dayOfWeek,
  dayOfMonth,
  date,
  runnerId,
  notifyOnSuccess,
}: ScheduleInput): CronSchedule | undefined {
  switch (schedulePeriod) {
    case undefined:
      return undefined
    case 'now':
      return {
        second: '*',
        minute: '*',
        hour: '*',
        dayOfMonth: '*',
        month: '*',
        dayOfWeek: '*',
        timeZoneName,
        runnerId,
        notifyOnSuccess,
        once: true,
      }
    case 'once': {
      return {
        second: seconds?.toString() ?? '0',
        minute: minutes?.toString() ?? '0',
        hour: hours?.toString() ?? '0',
        dayOfMonth: dayOfMonth?.toString() ?? '0',
        month: '0',
        dayOfWeek: dayOfWeek?.toString() ?? '0',
        date,
        timeZoneName,
        runnerId,
        notifyOnSuccess,
        once: true,
      }
    }
    case 'hour': {
      return {
        second: '0',
        minute: '0',
        hour: '*',
        dayOfMonth: '*',
        month: '*',
        dayOfWeek: '*',
        timeZoneName,
        runnerId,
        notifyOnSuccess,
      }
    }
    case 'day': {
      return {
        second: '0',
        minute: minutes?.toString() ?? '0',
        hour: hours?.toString() ?? '0',
        dayOfMonth: '*',
        month: '*',
        dayOfWeek: '*',
        timeZoneName,
        runnerId,
        notifyOnSuccess,
      }
    }
    case 'week': {
      return {
        second: '0',
        minute: minutes?.toString() ?? '0',
        hour: hours?.toString() ?? '0',
        dayOfMonth: '*',
        month: '*',
        dayOfWeek: dayOfWeek?.toString() ?? '0',
        timeZoneName,
        runnerId,
        notifyOnSuccess,
      }
    }
    case 'month': {
      return {
        second: '0',
        minute: minutes?.toString() ?? '0',
        hour: hours?.toString() ?? '0',
        dayOfMonth: dayOfMonth?.toString() ?? '0',
        month: '*',
        dayOfWeek: '*',
        timeZoneName,
        runnerId,
        notifyOnSuccess,
      }
    }
  }
}
